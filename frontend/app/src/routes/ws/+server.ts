import type { Socket, Peer } from '@sveltejs/kit';
import { RedisChatService, type ChatMessage } from '$lib/server/redis-chat';

function generateUsername(): string {
	return `User${Math.floor(Math.random() * 900) + 100}`;
}

// Tracks active WebSocket peers
const activePeers = new Map<Peer, { username: string; peerId: string }>();

export const socket: Socket = {
	// Handles the initial HTTP request upgrade to WebSocket
	upgrade(req) {
		console.log(`[WS Server] HTTP upgrade request for: ${req.url}`);
	},

	// Called when a new WebSocket connection is established
	async open(peer) {
		// Capture peer.id for reliable reference
		const peerId = peer.id;
		console.log(`[WS Server] Peer ${peerId} connected.`);
		try {
			const chatService = RedisChatService.getInstance();
			await chatService.initialize();

			const username = generateUsername();
			activePeers.set(peer, { username, peerId });
			await chatService.saveUser(peerId, username);
			console.log(`[WS Server] User ${username} (${peerId}) registered.`);

			// Send a welcome message only to the newly connected client.
			peer.send(
				JSON.stringify({
					type: 'welcome',
					message: 'Welcome to the chat!',
					username: username,
					timestamp: Date.now()
				} as ChatMessage)
			);

			// Subscribe peer to the 'chat' topic to receive broadcasted messages
			peer.subscribe('chat');
			console.log(`[WS Server] Peer ${peerId} (${username}) subscribed to 'chat'.`);

			// Send recent message history (user messages only)
			const recentMessages = await chatService.getRecentMessages(50);
			const userMessagesHistory = recentMessages.filter((msg) => msg.type === 'message');
			if (userMessagesHistory.length > 0) {
				peer.send(JSON.stringify({ type: 'history', messages: userMessagesHistory }));
				console.log(
					`[WS Server] Sent ${userMessagesHistory.length} history messages to ${peerId}.`
				);
			}
		} catch (error) {
			console.error(`[WS Server] Error in open handler for ${peerId}:`, error);
			try {
				peer.send(JSON.stringify({ type: 'error', message: 'Server connection setup error.' }));
				peer.close(1011, 'Server error during open');
			} catch (e) {
				console.error(e);
			}
			activePeers.delete(peer);
		}
	},

	// Called when a message is received from a client
	async message(peer, messageData) {
		const userInfo = activePeers.get(peer);
		if (!userInfo) {
			console.warn(`[WS Server] Message from unknown peer ${peer.id}. Ignoring.`);
			return;
		}
		const { username, peerId } = userInfo;

		try {
			const textMessage = String(messageData).trim();
			// Ignore empty messages
			if (!textMessage) return;

			const chatService = RedisChatService.getInstance();
			// Message DTO, ID will be generated by saveMessage
			const chatMsgDto: ChatMessage = {
				type: 'message',
				message: textMessage,
				username: username,
				timestamp: Date.now()
			};
			// Save message (which assigns server-side ID) and get the confirmed message
			const savedMessage = await chatService.saveMessage(chatMsgDto);

			// Publish the confirmed message (with server ID) to all subscribers of 'chat'
			peer.publish('chat', JSON.stringify(savedMessage));
			console.log(`[WS Server] Msg from ${username} (ID: ${savedMessage.id}) saved & published.`);
		} catch (error) {
			console.error(`[WS Server] Error in message handler for ${peerId}:`, error);
			try {
				peer.send(JSON.stringify({ type: 'error', message: 'Error processing message.' }));
			} catch (e) {
				console.error(e);
			}
		}
	},

	// Called when a client connection is closed
	async close(peer, event) {
		const userInfo = activePeers.get(peer);
		// Get peerId safely
		const peerId = userInfo ? userInfo.peerId : peer.id;
		console.log(
			`[WS Server] Peer ${peerId} disconnected. Code: ${event?.code}, Reason: ${event?.reason}`
		);

		if (userInfo) {
			try {
				await RedisChatService.getInstance().removeUser(peerId);
				console.log(`[WS Server] User ${userInfo.username} (${peerId}) removed from Redis.`);
			} catch (error) {
				console.error(`[WS Server] Error in close handler for ${peerId} (Redis cleanup):`, error);
			}
		}
		// Remove from active tracking
		activePeers.delete(peer);
	},

	// Called when a WebSocket error occurs for a specific peer
	error(peer, errorData) {
		const userInfo = activePeers.get(peer);
		const peerId = userInfo ? userInfo.peerId : peer.id;
		console.error(`[WS Server] Error for peer ${peerId}:`, errorData);

		if (userInfo) {
			console.log(
				`[WS Server] Removing user ${userInfo.username} (${peerId}) from tracking due to error.`
			);
		}
		activePeers.delete(peer);

		// Attempt to close the connection if possible
		try {
			if (peer && typeof peer.close === 'function') {
				peer.close(1011, 'Unrecoverable server-side WebSocket error');
			}
		} catch (e) {
			console.error(e);
		}
	}
};
